<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>Presentation</title>

		<link rel="stylesheet" href="dist/reset.css">
		<link rel="stylesheet" href="dist/reveal.css">
		<link rel="stylesheet" href="dist/theme/league.css" id="theme">
		<link rel="stylesheet" href="dist/theme/fonts/league-gothic/league-gothic.css">

		<!-- Theme used for syntax highlighted code -->
		<link rel="stylesheet" href="plugin/highlight/monokai.css" id="highlight-theme">
	</head>
	<body>
		<div class="reveal">
		<!--	<div class="slides">
				<section>
					<section> Slide 1</section>
					<section>Slide 1.1</section>
					<section data-transition="convex">Slide 1.2</section>
					<section>Slide 1.3</section>
					<section>Slide 1.5</section>
				</section>
				<section>Slide 2</section>
				<section>Slide 3</section>
			</div>
		</div>
-->
<div class="slides">
	
	<section>
		<section>
			<h1>ES2020 features</h1>
				<img data-natural-width="1920" data-natural-height="521" style="border:none; background: transparent; box-shadow:none;" 
				src="./img/logo.png" />
				<aside class="notes">
					Hello everyone! Today we are going to talk quickly about all ECMAScript2020 Features in 8 minutes. 
					ES2020 is new version of Javascript that officially became part of JS this year.
				</aside>
		</section>
		<section>
			<ul style="list-style: decimal-leading-zero;">
				<li>BigInt</li>
				<li>Nullish Coalescing operator</li>
				<li>Optional Chaining(Elvis operator)</li>
				<li>Promise.allSettled</li>
				<li>globalThis</li>
				<li>Dynamic import()</li>
				<li>String.prototype.matchAll</li>
				<li>For-in order mechanics</li>
				<li>import.meta</li>
				<li>export * as ns from "mod"</li>
			</ul>
			<aside class="notes">
				Take a look through the list of ES2020 Features. You may have already used some of them, but now they are officially part of JavaScript.
			</aside>
		</section>
	</section>
	<section>
		<section>
			<div data-block-type="text" style="width: 806px; left: 80px; top: 0px; height: auto;"
				data-block-id="68ec0e02954724344bb84c3298a8c49a">
				<h2>Big Int</h2>
			</div>
			<div data-block-type="text" style="height: auto;">
				<p style="font-size: 18px;">Now you can feel free to use numbers larger  than 2<sup>53</sup>-1 in your JS code.</p>
				<p style="font-size: 18px;">To use this feature you should append "n" to your number like that:</p>
<pre><code style="max-height: 900px !important;">
	let num=Number.MAX_SAFE_INTEGER
	console.log("result:", ++num)
	result: 9007199254740992
	console.log("result:", ++num)
	result: 9007199254740992
	console.log("result:", ++num)
	result: 9007199254740992
	let number=9007199254740999n;
	console.log("result:",++number);
	result: 9007199254741000n
	number*=2n;
	console.log("result:",number);
	result: 18014398509482000n
</code></pre>
				<aside class="notes">BigInt,allows developers to have much greater integer representation in their JS code
					 for data processing for data handling.	At the moment the maximum number you can store as an integer in JavaScript is
					2<sup>53</sup>-1(2 to 53 degrees minus 1)
				</aside>
			</div>
		</section>
	</section>
	<section>
		<section>
			<h2>Nullish Coalescing</h2>
			<p>Nullish coalescing adds the ability to truly check nullish values instead of falsey values.</p>
			<p>Example with '??'</p>
			<img src="./img/Nullish1.png" alt="Nullish1.png">
			<aside class="notes">
				In JavaScript, a lot of values are falsey, like empty strings, the number 0, undefined, null, false, NaN, and so on.
				However, a lot of times you might want to check if a variable is nullish – that is if it is either undefined or null, 
				like when it's okay for a variable to have an empty string, or even a false value.
			</aside>
		</section>
		<section>
			<p>Example with '||'</p>
			<img src="./img/Nullish2.png" alt="Nullish2.png">
			<aside class="notes">
				You can see the difference between || and ?? operators.
			</aside>
		</section>
	</section>
	<section>
	
			<h2>Optional Chaining</h2>
			<img src="./img/optionalChaining.png" alt="optionalChaining.png">
			<aside class="notes">
				Optional chaining syntax allows us to access deeply nested object properties without worrying if the property exists or not.
				 If property exists, we'll get expected value, else undefined will be returned.
			</aside>
	</section>
		<section>
			<h2>Promise.allSettled</h2>
			<p>Promise.allSettled returns a promise that’s fulfilled with an array of promise state snapshots,
				 but only after all the original promises have settled</p>
				 <img src="./img/promiseAllSettled.png" alt="promiseAllSettled.png">
			<aside class="notes">
				Promise.allSettled returns a promise that’s fulfilled with an array of promise state snapshots,
				 but only after all the original promises have settled. Promise is settled if it is not pending(resolved or rejected)
			</aside>
		</section>
	</section>
	<section>
		
			<h2>globalThis</h2>
			<p>globalThis feature will help us to write cross-platform code which could run on Node, in the browser environment, and also inside web-workers.</p>
			<img src="./img/globalThis1.png" alt="globalThis1.png">
			<img src="./img/globalThis2.png" alt="globalThis2.png">
			<aside class="notes">
				globalThis feature will help us to write cross-platform code which could run on Node, in the browser environment, and also inside web-workers.
				You can have a problem with getting global object(global for Node,window for browsers, self for web-workers).
				globalThis always refers to the global object, no matter where the code is executing.
			</aside>
		
	</section>
	<section>
		<h2>Dynamic import</h2>
		<p>Dynamic import() returns a promise for the module namespace object of the requested module.</p>
		<pre><code style="max-height: 900px !important;">
const moduleToImport = 'exampleModule.js';
const resp = import(moduleToImport).then( x => x.print('hi'));
(async function(){
const module = await import (moduleToImport);
module.print('hi,there');
});
if(exampleCondition){
const module = await import (moduleToImport);
module.print('hi,there2');
}
		</code></pre>
		<aside class="notes">
			Dynamic import in JavaScript give you the option to import '.js' files dynamiclly as modules.
			This is just like how you do it with Webpack and Babel at the moment.
			This feature will help you with code splitting,without the webpack or other module bundlers.
			Imports can now be assigned to a variable using async/await dynamically. 
			You can also conditionally load code in an if-else block if you need it.
		</aside>
	</section>
	<section>
		
		<h2>For-in mechanics</h2>
		<p>The ECMA specification did not specify in which order for (const element in array)  should run. Even though browsers implemented
		 a consistent order on their own before now, this has been officially standardized in ES2020.</p>
		 <div style="height: 30%;width: 30%;margin: 0 auto;">
		 <img style="object-fit: contain;" src="./img/Gears.png" alt="Gears.png"></div>
		<aside class="notes">
			The specification didn't specify the order in for-in loop. JavaScript engines came up with their own implementations,
			 but now order is standardized and defined in ES2020.
		</aside>
	
	</section>

	<section>
		<h2>matchAll</h2>
		<p>matchAll matches all results and returns iterator agains a regex</p>
		<pre><code style="max-height: 900px !important;">
const regexp = /(Hello )\w+/g;
const str = 'Hello World!,bye John Doe. Hello there=)';
const matches = str.matchAll(regexp);
console.log(Array.from(matches));
(2) [Array(2), Array(2)]
0: (2) ["Hello World", "Hello ", index: 0, input: "Hello World!,bye John Doe. Hello there=)", groups: undefined]
1: (2) ["Hello there", "Hello ", index: 27, input: "Hello World!,bye John Doe. Hello there=)", groups: undefined]
length: 2
__proto__: Array(0)
}
		</code></pre>
		<aside class="notes">
			If you have a Regular Expression which matches a lot of occurences  in a string then you should use matchAll method.
		</aside>
	</section>
		<section>
			<h2>import.meta</h2>
			<pre><code style="max-height: 900px !important;">
<script type="module" src="module.js"></script>
console.log(import.meta); // { url: "file:///home/user/module.js" }
}
						</code></pre>
			<aside class="notes">
				The import.meta object was created by the ECMAScript implementation, with a null prototype.
				You can access meta information about the module using the import.meta object.
				It returns an object with a url property indicating the base URL of the module. 
			</aside>
		</section>
		<section>
			<h2>Module Namespace Exports</h2>
			<pre><code style="max-height: 900px !important;">
import * as cards from './cards.js';
export * as cards from './cards.js';

export{cards};
}
						</code></pre>
			<aside class="notes">
				In JavaScript modules, it was already possible to use import, but now we have symmetric export syntax. 
			</aside>
		</section>

</div>
</div>
		<script src="dist/reveal.js"></script>
		<script src="plugin/notes/notes.js"></script>
		<script src="plugin/markdown/markdown.js"></script>
		<script src="plugin/highlight/highlight.js"></script>
		<script>
			// More info about initialization & config:
			// - https://revealjs.com/initialization/
			// - https://revealjs.com/config/
			Reveal.initialize({
				hash: true,

				// Learn about plugins: https://revealjs.com/plugins/
				plugins: [ RevealMarkdown, RevealHighlight, RevealNotes ]
			});
		</script>
	</body>
</html>
